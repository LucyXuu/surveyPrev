---
title: "Spatial smoothing of DHS indicators using the **surveyPrev** package"
author: "Qianyu Dong, Zehang Richard Li, Andrea Boskovic, Jon Wakefield"
date: "`r Sys.Date()`"
bibliography: main.bib
output: 
  bookdown::html_document2:
    base_format: rmarkdown::html_vignette
    toc: true
  bookdown::pdf_book:
    number_sections: true
    toc: true
vignette: >
  \VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Prevalence mapping using DHS data}
  %\usepackage[utf8]{inputenc}
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, tidy = FALSE, eval=TRUE, cache = TRUE, out.width = "100%")

```

\clearpage
# Overview

In this vignette, we describe how prevalence mapping using DHS data can be carried out. The vignette is organized as follows. In Section \@ref(sec:data) we first describe the data preparation steps to obtain and process the relevant DHS survey data in R. In Section \@ref(sec:model) we describe the following models:

1. Direct estimates in Section \@ref(sec:direct).
2. Area-level Fay-Herriot model in Section \@ref(sec:area-level).
3. Cluster-level model in Section \@ref(sec:cluster-level).

In Section \@ref(sec:model2), we describe additional models for estimating prevalence at Admin 2 level. Section \@ref(sec:aggregation) is about aggregation model results to higher admin levels.




# Data Preparation {#sec:data}
  
## Prerequisites

As of the current version of the package, the following pieces of data are needed to produce small area estimations for DHS surveys:


+ **DHS survey data**: Depending on the indicator, different types of DHS files are used as input. This can be done within R, so there is no need to download files locally from the DHS website. See the section on downloading DHS data for details.
+ **Spatial polygon files** for the desired admin level: These can be downloaded from GADM site^[[https://gadm.org/download_country.html](https://gadm.org/download_country.html)]. 
+ **Population map**: These can be downloaded from WorldPop site^[[https://hub.worldpop.org/project/categories?id=8](https://hub.worldpop.org/project/categories?id=8)].


## Install _**surveyPrev**_  

The latest **surveyPrev** package can be installed from CRAN with

```{r, eval = FALSE}
install.packages(surveyPrev)
```

The development version of the **surveyPrev** package can be installed from GitHub with

```{r, message=FALSE,warning=FALSE, eval=FALSE}
library(devtools)
install_github("richardli/surveyPrev")
```

After installation, the package can be loaded with 

```{r, message=FALSE,warning=FALSE, eval = TRUE}
library(surveyPrev)
```


In particular, one of the key required packages, `INLA` is not available on CRAN or GitHub, but can be installed with the following codes [@rue2009inla]. 

```{r pkg, eval = FALSE, tidy = FALSE}
install.packages("INLA", repos=c(getOption("repos"), 
                  INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
library(INLA)
```

The following packages are also needed to run the examples in this vignette.

```{r, message=FALSE,warning=FALSE, eval = TRUE}
library(geodata)
library(sf)
library(SUMMER)
library(rdhs)
library(ggplot2)
library(patchwork)
library(dplyr)
library(kableExtra)
```




## Built-in indicators

```{r, echo = FALSE, eval = TRUE}
data(surveyPrevIndicators)
```

Currently, the `surveyPrev` package supports `r dim(surveyPrevIndicators)[1]` indicators. The list of indicators and their IDs can be found in the `surveyPrevIndicators` dataset. Either the ID and alternative ID in the `surveyPrevIndicators` dataset can be used to retrieve the indicator. The full list of indicators and their IDs are summarized in Table \@ref(tab:indic).

```{r, eval = FALSE}
data(surveyPrevIndicators)
head(surveyPrevIndicators)
```

```{r indic, eval = TRUE, table.width = "100%", echo = FALSE}
is_html_output = function() {
  knitr::opts_knit$get("rmarkdown.pandoc.to") == "html"
}
if(is_html_output()){
  kbl(surveyPrevIndicators, align = 'ccl', 
    caption = "List of built-in indicators in the surveyPrev package.") %>%
  kable_styling()
}else{
  kbl(surveyPrevIndicators, align = 'ccl', 
    caption = "List of built-in indicators in the surveyPrev package.") %>%
  column_spec(3, width = "25em")
}
```


In this vignette, we consider estimating the percentage of women who had a live birth in the five years before the survey who had four or more antenatal care visits. This indicator can be extracted with `indicator = "ancvisit4+"` or `indicator = "RH_ANCN_W_N4P"`. 


## Customized indicators
Details on more common DHS indicators can be found in the Guide to DHS Statistics^[https://dhsprogram.com/data/Guide-to-DHS-Statistics/](https://dhsprogram.com/data/Guide-to-DHS-Statistics/) by searching for an indicator. User-specified function can also be used to process raw DHS data into new indicators. Please refer to the vignette on _Creating Customized Indicators for **surveyPrev**_ for more details.


## DHS survey data 

Processing the binary indicator from the raw DHS data consist of two steps: 
1. download the relevant DHS data recode using `getDHSdata()`, or manually from the DHS website,
2. create a data frame with the binary indicator and relevant information using `getDHSindicator()`. 

The `getDHSdata()` function downloads the relevant DHS data directly from the DHS website using the **rdhs** package. This step requires users to

1. register with DHS to gain data access, 
2. set up the DHS account login details in R with `rdhs::set_rdhs_config()`.

```{r,eval=FALSE}
rdhs::set_rdhs_config(email = "your_email",
                project = "your_registered_DHS_project_title")
```

After setting up the DHS account information, `getDHSdata()` can be used to download the relevant survey files directly into R. If data download using the API fails, or if it is preferred to work with downloaded data files offline, you may also manually download the file from the DHS website and read into R. The `getDHSdata()` function returns a message specifying which file is used (e.g., Individual Record file for the ANC visit example). 

```{r,message=FALSE,warning=FALSE}
indicator <- "ancvisit4+"
year <- 2018
country <- "Zambia"
dhsData <- getDHSdata(country = country, indicator = indicator, year = year)
```

We then use `getDHSindicator()` to process the raw survey data into a data frame, where the column `value` is the indicator of interest. The data frame also contains information specifying survey designs in the **survey** package, including cluster ID, household ID, survey weight and strata information. 

```{r}
data <- getDHSindicator(dhsData, indicator = indicator)
head(data)
```

## Spatial information

The `getDHSgeo()`function downloads the GPS data for cluster locations, also through the **rdhs** package. This step loads in the GPS location as a `SpatialPointsDataFrame`, but it can also be performed manually by downloading the GPS file from the DHS website. The GPS location of the clusters are used to match clusters to regions at different admin levels. 

```{r}
geo <- getDHSgeo(country = country, year = year)
```

In the case of Zambia, the maps are already included in the package as example datasets (`data(ZambiaAdm1)` and `data(ZambiaAdm2)`) so we load them directly within R. For other countries, the Admin 1 and Admin 2 boundary shapefiles can be downloaded from the GADM site^[[https://gadm.org/download_country.html](https://gadm.org/download_country.html)] and read into R manually. Another alternative is to use the **geodata** and **sf** package to download the maps from the GADM site and load them in R directly.

```{r}
poly.adm1 <- geodata::gadm(country="ZMB", level=1, path=tempdir())
poly.adm1 <- sf::st_as_sf(poly.adm1)
poly.adm2 <- geodata::gadm(country="ZMB", level=2, path=tempdir())
poly.adm2 <- sf::st_as_sf(poly.adm2)
```



The `clusterInfo()` function extracts Admin 1 and Admin 2 area information for each cluster. To avoid confusion in countries that have duplicated region names, we create new labels for Admin 2 regions using the variable `admin2.name.full`.  The clusters with invalid GPS locations are saved in the `wrong.points` object. 

```{r}
cluster.info <- clusterInfo(geo=geo, poly.adm1=poly.adm1, poly.adm2=poly.adm2)
head(cluster.info$data)
head(cluster.info$wrong.points)
```


The `adminInfo()` function computes the spatial adjacency matrix, and if supplied with additional information on population, combines needed information for each administrative area, including the name, population, and urban population fractions of each administrative area. The `admin.mat` object stores adjacency matrix for spatial models. We will ignore the population information for now and focus on only information from the DHS data, and will return to the population information in Section \@ref(sec:aggregation). 

```{r}
admin.info1 <- adminInfo(poly.adm = poly.adm1, admin = 1)
admin.info2 <- adminInfo(poly.adm = poly.adm2, admin = 2)
head(admin.info2$data)
```



# Prevalence Estimation With Only DHS Data {#sec:model}

## Direct estimates {#sec:direct}

For $y_j$ be the binary outcome of interest for the $j^{\text{th}}$ individual in the survey and $w_j$ be the design weight associated with this individual.  For a given area denoted as $i$, we have

$$ \hat p^{HT}_{i}=\frac {\sum_{j \in S_i} y_j w_j}{\sum_{j \in S_i} w_j}$$

where $S_i$ is the set of individual index within the $i$-th region. The `directEST()` function calculates direct estimates at different Admin levels using the `SUMMER::smoothSurvey()` function in the **SUMMER** package internally [@li2020summer].  The output of the function includes the direct estimates and their variance, standard error, and confidence intervals based on the specified confidence level. The confidence intervals are computed on the logit scale, i.e., if we use $D_i$ to denote the design-based variance of $\hat p^{HT}_i$, then the asymptotic design-based variance of $\text{logit}(\hat p^{HT}_i)$ is
\[
V_i  = \frac{D_i}{(\hat p^{HT}_i)^2(1-\hat p^{HT}_i)^2}
\]
and we compute the confidence interval on the probability scale to be 
\[
(\text{expit}[\text{logit}(\hat p^{HT}_i) - z_{\alpha/2}V_i^{1/2}], \;\;
\text{expit}[\text{logit}(\hat p^{HT}_i) + z_{\alpha/2}V_i^{1/2}]).
\]

Currently the package defaults to a two-stage stratified cluster sampling design, with the sampling clusters (enumeration areas) being stratified by Admin 1 areas and urban/rural status, which is the most common sampling design in the DHS. 


```{r}
res_ad1 <- directEST(data = data,
                   cluster.info = cluster.info,
                   admin = 1)
head(res_ad1$res.admin1)
```


For national level (`admin = 0`), the function can additioanlly produce urban- and rural-specific direct estimates by specifying argument `strata`. 

```{r}
res_ad0 <- directEST(data=data,
                   cluster.info= cluster.info,
                   admin=0,
                   strata="all")
res_ad0_urban <- directEST(data=data,
                   cluster.info= cluster.info,
                   admin=0,
                   strata="urban")
res_ad0_rural <- directEST(data=data,
                   cluster.info= cluster.info,
                   admin=0,
                   strata="rural")
list(all = res_ad0$res.admin0, 
      urban = res_ad0_urban$res.admin0, 
      rural = res_ad0_rural$res.admin0)
```


## Area-level Fay-Herriot model {#sec:area-level}


Fay-Herriot models provides smoothed estimates at the areal level using direct estimate $\hat p^{HT}_{i}$ as input. The direct estimates are modeled as a noisy observation of the true prevalence, with the variance of noise determined by the design-based variance. We consider the spatial Fay-Herriot model for the logit transformed direct estimates, which is defined as follows:

$$\text{logit}(\hat p^{HT}_{i})|\lambda_{i} \sim\textrm{Normal}(\lambda_{i}, V_{i}^{HT}),$$
$$\lambda_{i}= \mathbf x_i^{T} \mathbf{\beta} + e_i+S_i.$$
Here $\text{expit}(\lambda_{i})$ is the latent true prevalence, $\mathbf{x}_i$ represents area-level covariates, and $e_i$ and $S_i$ are  unstructured and structured spatial random effects. 

As of now the package allows only an overall intercept for the fixed effect. The default prior for the intercept is $N(0, 1000)$. The structured and non-structured random effects are implemented via the BYM2 parameterization, with default PC priors such that the marginal standard deviation has a prior such that $Prob(\sigma > 1) = 0.01$ and the proportion of variation explained by the spatial effect, $\phi$ has a prior such that $Prob(\phi > 0.5) = 2/3$ [@riebler2016bym2; @simpson2017pc]. 


The `fhModel()` calculates spatial Fay Herriot estimates at different administrative levels using `SUMMER::smoothSurvey()`. Users can specify either only i.i.d. random effect (i.e., no $S_i$ term) or the Besag-York-Mollié (BYM) model by setting `model = "iid"` or `model = "bym2"`. The function returns model results at the specified admin level with `aggregation = FALSE`. Aggregated to higher admin levels is possible with `aggregation = TRUE` when additional population information is provided. The aggregation steps are described in more details in Section \@ref(sec:aggregation). 


```{r}
smth_res_ad1_bym2 <- fhModel(data,
                        cluster.info = cluster.info,
                        admin.info = admin.info1,
                        admin = 1,
                        model = "bym2",
                        aggregation =FALSE)

smth_res_ad1_iid <- fhModel(data, 
                        cluster.info = cluster.info, 
                        admin.info = admin.info1,
                        admin = 1, 
                        model = "iid",
                        aggregation =FALSE)
head(smth_res_ad1_bym2$res.admin1) 

```


## Cluster-level model {#sec:cluster-level}

Cluster-level models assume smoothing models for counts of events in each cluster [@wakefield2020small; @li2020summer]. Let $Y_c$ be the number of events in cluster $c$, and $n_c$ be the number of individuals at risk, where $c= 1,\dots,C$.

$$Y_c|p_c,d\sim \textrm{BetaBinomial}(n_c,p_c,d),$$
$$p_c=\textrm{expit}(\alpha+\mathbf{x}_c\beta+e_{i[s_c]}+S_{i[s_c]}),$$

where $\alpha$ is the intercept, $\mathbf{x}_c$ are cluster-specific covariates and $i[s_c]$ indexes the area within which the cluster $s_c$ resides. Similar to the area-level model, $e_i$ and $S_i$ are the iid and spatial random effects with the same prior as before. The overdispersion parameter, $d=\frac{1}{\alpha+\beta+1}$, is between 0 and 1 and represent the the intracluster correlation between Bernoulli draws within cluster.
<!-- , corr($z_k,z_{k'}$), where $z_k$ is the binary response in $y_c$, $y_c=\sum_{k=1}^{n_c}z_k$). -->
The defaul prior for $d$ is $\text{logit}(d) \sim \text{Normal}(0,0.4)$.  


Currently, the package allows the specification of the fixed effect to contain either an overall intercept only (i.e., unstratified model), or with an additional urban-rural effect (i.e., stratified model). For the stratified model, $p_c$ is parameterized by 
$$p_c=\textrm{expit}(\alpha+\gamma\times I(s_c \in \textrm{urban})+x_c\beta+e_{i[s_c]}+S_{i[s_c]}).$$

The area-level risk is defined as $$p_i=q_i\times \text{expit}(\alpha+\gamma+e_{i[s_c]}+S_{i[s_c]})+(1-q_i)\times \text{expit}(\alpha+e_{i[s_c]}+S_{i[s_c]}),$$ where $q_i$ is the proportion of urban population as defined by the survey design in area $i$.

The `clusterModel()` function fits the cluster-level model above. Users can specify whether to include the urban-rural stratification by setting `stratification = TRUE`, and either i.i.d. or BYM model by setting `model = "bym2"` or `model = "iid"`. For the the overdispersion parameter $d$, users can change the prior mean and precision through `overdisp.mean` and `overdisp.prec`. 


We first fit the non-stratified model in both Admin 1 and Admin 2 below. 


```{r}
cl_res_ad1 <- clusterModel(data=data,
                   cluster.info=cluster.info,
                   admin.info  = admin.info1,
                   stratification = TRUE,
                   model = "bym2",
                   admin = 1,
                   aggregation =FALSE,
                   CI = 0.95)

cl_res_ad2 <- clusterModel(data=data,
                   cluster.info= cluster.info,
                   admin.info = admin.info2,
                   model = "bym2",
                   stratification =FALSE,
                   admin = 2,
                   aggregation =FALSE,
                   CI = 0.95)
```


The estimates can be extracted as follows

```{r}
head(cl_res_ad1$res.admin1)
head(cl_res_ad2$res.admin2)
```


## Visualizing prevalence estimates {#sec:vis}

We can use `mapPlot()` function from the SUMMER package to visualize estimates and standard errors. We note that for Admin 2 estimates, **surveyPrev** uses a recreated region name in the form of [admin1_name]\_[admin2_name] to avoid duplicated Admin 2 names. This new region identifier is assigned a column name of `admin2.name.full` in the output. Thus when plotting, we need to manually create the `admin2.name.full` in the spatial polygon object.

```{r ,fig.dim = c(6, 4),fig.cap="Comparing Admin 1 direct estimates, Admin 1 Fay–Herriot, Admin 1 and Admin 2 unstratified cluster-level estimates", out.width = "100%"}
poly.adm2$admin2.name.full=paste0(poly.adm2$NAME_1,"_",poly.adm2$NAME_2)

# Make all plots share the same color range
min= min(res_ad1$res.admin1$direct.est,smth_res_ad1_bym2$mean,
         cl_res_ad1$res.admin1$mean,cl_res_ad2$res.admin2$mean)
max= max(res_ad1$res.admin1$direct.est,smth_res_ad1_bym2$mean,
         cl_res_ad1$res.admin1$mean,cl_res_ad2$res.admin2$mean)
ylim=c(min,max)


g1 <- mapPlot(data = res_ad1$res.admin1, geo = poly.adm1,
              by.data = "admin1.name",  by.geo = "NAME_1", 
              variable = "direct.est", legend.label = "Admin 1 Direct",
              ylim =ylim, removetab = TRUE)

g2 <- mapPlot(data = smth_res_ad1_bym2$res.admin1, geo = poly.adm1,
              by.data = "admin1.name", by.geo = "NAME_1", 
              variable = "mean", legend.label = "Admin 1 Fay–Herriot", 
              ylim =ylim, removetab = TRUE)

g3 <- mapPlot(data = cl_res_ad1$res.admin1, geo = poly.adm1, 
              by.data = "admin1.name", by.geo = "NAME_1", 
              variable = "mean",  legend.label = "Admin 1 unstratified", 
              ylim = ylim, removetab = TRUE)

g4 <- mapPlot(data = cl_res_ad2$res.admin2, geo = poly.adm2, 
              by.data = "admin2.name.full", by.geo = "admin2.name.full",
              variable = "mean", legend.label = "Admin 2 unstratified", 
              ylim = ylim, removetab = TRUE)

(g1 + g2) / (g3 + g4)
```


The `scatterPlot()` function takes results from two model outputs, and produce a scatter plot of the selected variable. Here we visualize the comparison of the estimates and standard deviations.

```{r, warning=FALSE,echo=TRUE,fig.show="hold", fig.height = 5, fig.width = 10,fig.cap="Comparing Admin 1 direct estimates and Admin 1 Fay–Herriot"}
s1 <- scatterPlot(
      res1=res_ad1$res.admin1,
      res2=smth_res_ad1_bym2$res.admin1,
      value1="direct.est",
      value2="mean",
      by.res1="admin1.name",
      by.res2="admin1.name",
      title="Admin1: Spatial Fay Herriot vs Direct estimate",
      label1="Direct Est",
      label2="Spatial Fay-Herriot")
s2 <- scatterPlot(
      res1=res_ad1$res.admin1,
      res2=smth_res_ad1_bym2$res.admin1,
      value1="direct.se",
      value2="sd",
      by.res1="admin1.name",
      by.res2="admin1.name",
      title="Admin1: Spatial Fay–Herriot vs Direct SE",
      label1="Direct Est",
      label2="Spatial Fay–Herriot")
s1 +s2
```
 

```{r, warning=FALSE,echo=TRUE,fig.show="hold", fig.height = 4, fig.width = 8,fig.cap="Comparing Admin 1 direct estimates and Admin 1 unstratified cluster-level estimates"}
s1 <- scatterPlot(
      res1=res_ad1$res.admin1,
      res2=cl_res_ad1$res.admin1,
      value1="direct.est",
      value2="mean",
      by.res1="admin1.name",
      by.res2="admin1.name",
      title="Admin1: Cluster-level model vs Direct estimate",
      label1="Direct Est",
      label2="Cluster-level model")
s2 <- scatterPlot(
      res1=res_ad1$res.admin1,
      res2=cl_res_ad1$res.admin1,
      value1="direct.se",
      value2="sd",
      by.res1="admin1.name",
      by.res2="admin1.name",
      title="Admin1: Cluster-level model vs Direct SE",
      label1="Direct Est",
      label2="Cluster-level model")
s1 +s2
```





# More Models for Admin 2 Estimates {#sec:model2}
In this section, we discuss additional models that can be fit to estimate prevalences at the Admin 2 level. These models either require additional care from the users in examining the assumptions and results, or require additional information not readily available from the DHS data alone. 

## Admin 2 direct estimates {#sec:direct2} 

In general, direct estimates at Admin 2 are unstable. For countries with a large number of Admin 2 areas, some of the direct estimates can be undefined if there is no cluster in the area.

```{r}
res_ad2 <- directEST(data = data,
                   cluster.info = cluster.info,
                   admin = 2,
                   aggregation = FALSE)
```


## Admin 2 area-level Fay-Herriot model {#sec:area-level2}

Fay-Herriot model at admin2 level can be fit by treating areas without direct estimates as missing data, though it is usually not recommended due to data sparsity. In addition, numerical issue arise when design-based variance of direct estimate is close to zero and logit precision become too large. A potential fix for this issue is to identify regions with too small design variance(< 1e-30), and delete the clusters in these regions, before fitting the model. However, this step creates additional bias in the results if the number of clusters deleted is large.


```{r}
bad_admin2 <- subset(res_ad2$res.admin2, direct.var < 1e-30)$admin2.name.full
# identify clusters in these regions
bad_clusters <- subset(cluster.info$data, admin2.name.full %in% bad_admin2)$cluster
# Run FH model without these clusters
smth_res_ad2 <- fhModel(subset(data, !cluster %in% bad_clusters),
                    cluster.info = cluster.info,
                    admin.info = admin.info2,
                    admin = 2,
                    model = "bym2",
                    aggregation = FALSE)
head(smth_res_ad2$res.admin2)
```


## Admin 2 cluster-level model with urban/rural stratification {#sec:cluster-level2}

In situations where the urban and rural prevalence are different, the urban/rural stratification variable needs to be included in the model. This can be achieved by setting `stratification = TRUE`. The returned results then consist of urban-specific, rural-specific, and the overall area-level prevalences. In order to facilitate aggregation for cluster-level model with urban/rural effects, we need to know the fraction of urban population by each administrative region. This computation can be non-trivial and requires external information (i.e., the urban/rural definition by census), so we omit this step from this document for now and assume such information is already obtained from a difference source. he urban proportions for women of age 15 to 49 in Zambia in 2018 has been pre-computed and saved in `ZambiaPopWomen$admin1_urban` and `ZambiaPopWomen$admin2_urban`.

```{r}
head(ZambiaPopWomen$admin2_urban)
```

Given the urban/rural proportions, we first add the information into `admin.info2` using `adminInfo()`.T


```{r, tidy = F}
admin.info2 <- adminInfo(poly.adm = poly.adm2, 
                         admin = 2,
                         proportion = ZambiaPopWomen$admin2_urban)
head(admin.info2$data)
```

We can then fit the stratified cluster-level model by specifying `stratification = TRUE`. 

```{r}
cl_res_ad2_T <- clusterModel(data=data,
                   cluster.info=cluster.info,
                   admin.info = admin.info2,
                   model = "bym2",
                   stratification = TRUE,
                   admin = 2, 
                   CI = 0.95)
```

The `compare=FALSE` in `intervalPlot()`is specifically designed for cluster models with urban/rural stratification. It presents a comparison of Admin 2 estimates with credible intervals within an Admin 1 region. 

```{r,fig.show='hold', fig.height = 15, fig.width = 10, fig.cap="Comparing Admin 2 estimates with credible intervals within an Admin 1 region"}
plots <- intervalPlot(compare = FALSE, model = list("model"=cl_res_ad2_T))
patchwork::wrap_plots(plots, ncol = 2)
```



## Visualizing Admin 2 prevalence estimates  {#sec:vis2}

We can compare the estimates on a map using `mapPlot()` function in **SUMMER** as before.

```{r ,warning=FALSE,echo=TRUE,fig.show="hold",fig.dim = c(6, 4), out.width = "100%", fig.cap="Comparing Admin 2 direct estimates, Admin 2 Fay–Herriot, Admin 2 unstratified and stratified cluster-level estimates"}
min= min(res_ad2$res.admin2$direct.est,smth_res_ad2$res.admin2$mean,
         cl_res_ad2$res.admin2$mean,
         cl_res_ad2_T$res.admin2[cl_res_ad2_T$res.admin2$type=="full",]$mean)
max= max(res_ad2$res.admin2$direct.est,smth_res_ad2$res.admin2$mean,
         cl_res_ad2$res.admin2$mean,
           cl_res_ad2_T$res.admin2[cl_res_ad2_T$res.admin2$type=="full",]$mean)
ylim=c(min,max)


g1 <- mapPlot(data = res_ad2$res.admin2, geo = poly.adm2, 
              by.data = "admin2.name.full", by.geo = "admin2.name.full", 
              variable = "direct.est", legend.label = "Admin 2 Direct", 
              ylim =ylim, removetab = TRUE)

g2 <- mapPlot(data = smth_res_ad2$res.admin2, geo = poly.adm2, 
              by.data = "admin2.name.full", by.geo = "admin2.name.full", 
              variable = "mean", legend.label = "Admin 2 Fay–Herriot", 
              ylim =ylim, removetab = TRUE)

g3 <- mapPlot(data = cl_res_ad2$res.admin2, geo = poly.adm2,
              by.data = "admin2.name.full", by.geo = "admin2.name.full", 
              variable = "mean", legend.label = "Admin 2 unstratified", 
              ylim = ylim, removetab = TRUE)


g4 <- mapPlot(data = cl_res_ad2_T$res.admin2[cl_res_ad2_T$res.admin2$type=="full",], 
              geo = poly.adm2, by.data = "admin2.name.full", by.geo = "admin2.name.full", 
              variable = "mean", legend.label = "Admin 2 stratified", 
              ylim = ylim, removetab = TRUE)

(g1 + g2)/(g3+ g4)


```


The following are model comparisons using `scatterPlot()`. Admin 2 direct estimates may not cover all Admin 2 areas, the red triangle points on the edges meaning missing direct estimates.

```{r, warning=FALSE,echo=FALSE,fig.show="hold", fig.height = 5, fig.width = 10, fig.cap="Comparing Admin 2 direct estimates and Admin 2 Fay–Herriot estimates"}
s1 <- scatterPlot(
      res1=res_ad2$res.admin2,
      res2=smth_res_ad2$res.admin2,
      value1="direct.est",
      value2="mean",
      by.res1="admin2.name.full",
      by.res2="admin2.name.full",
      title="Admin2: Spatial Fay Herriot vs Direct estimate",
      label1="Direct Est",
      label2="Spatial Fay-Herriot")
s2 <- scatterPlot(
      res1=res_ad2$res.admin2,
      res2=smth_res_ad2$res.admin2,
      value1="direct.se",
      value2="sd",
      by.res1="admin2.name.full",
      by.res2="admin2.name.full",
      title="Admin2: Spatial Fay–Herriot vs Direct SE",
      label1="Direct Est",
      label2="Spatial Fay–Herriot")
s1 + s2
```

```{r, warning=FALSE,echo=FALSE,fig.show="hold", fig.height = 5, fig.width = 10, fig.cap="Comparing Admin 2 direct estimates and Admin 2 unstratified cluster-level estimates"}
s1 <- scatterPlot(
    res1=res_ad2$res.admin2,
    res2=cl_res_ad2$res.admin2,
    value1="direct.est",
    value2="mean",
    by.res1="admin2.name.full",
    by.res2="admin2.name.full",
    title="Admin2: Cluster-level model vs Direct estimate",
    label1="Direct Est",
    label2="Cluster-level model")
s2 <- scatterPlot(
    res1=res_ad2$res.admin2,
    res2=cl_res_ad2$res.admin2,
    value1="direct.se",
    value2="sd",
    by.res1="admin2.name.full",
    by.res2="admin2.name.full",
    title="Admin2: Cluster-level model vs Direct SE",
    label1="Direct Est",
    label2="Cluster-level model")
s1 + s2
```

```{r, warning=FALSE,echo=FALSE,fig.show="hold", fig.height = 5, fig.width = 10, fig.cap="Comparing Admin 2 direct estimates and Admin 2 unstratified cluster-level estimates"}
s1 <- scatterPlot(
    res1=smth_res_ad2$res.admin2,
    res2=cl_res_ad2$res.admin2,
    value1="mean",
    value2="mean",
    by.res1="admin2.name.full",
    by.res2="admin2.name.full",
    title="Admin2: Cluster-level model vs Fay–Herriot estimate",
    label1="Admin 2 Fay–Herriot",
    label2="Cluster-level model")
s2 <- scatterPlot(
    res1=smth_res_ad2$res.admin2,
    res2=cl_res_ad2$res.admin2,
    value1="sd",
    value2="sd",
    by.res1="admin2.name.full",
    by.res2="admin2.name.full",
    title="Admin2: Cluster-level model vs Fay–Herriot SE",
    label1="Admin 2 Fay–Herriot",
    label2="Cluster-level model")
s1 + s2
```


# Aggregation to higher admin levels {#sec:aggregation}

## Computing population size from WorldPop raster

Population fractions are necessary to aggregate estimates from finer administrative regions to higher levels. The script below demonstrates the creation of a pixel-level population raster at the 100m by 100m level for women of age 15 to 49 in Zambia in 2018. The corresponding age-sex-specific population estimates can be found at [https://hub.worldpop.org/geodata/summary?id=16429](https://hub.worldpop.org/geodata/summary?id=16429). The path to the downloaded .tiff files are specified in the `pop_dir` object. The `aggPopulation()` aggregates population data from the population raster into admin levels based on the input shapefiles we read in previous step. Here we aggregate pixel-level population for women of age 15 to 49 in Zambia in 2018 into both Admin 1 and Admin 2 levels.

```{r, eval = FALSE}
library(raster)
pop.abbrev <- "ZMB"
year <- 2018
pop.dir <- "../data/Zambia/worldpop"

## first sum up four rasters female  15-49
f_15_name <- paste0(pop.dir, "/", pop.abbrev, '_f_15_', year, '.tiff')
f_20_name <- paste0(pop.dir, "/", pop.abbrev, '_f_20_', year, '.tiff')
f_25_name <- paste0(pop.dir, "/", pop.abbrev, '_f_25_', year, '.tiff')
f_30_name <- paste0(pop.dir, "/", pop.abbrev, '_f_30_', year, '.tiff')
f_35_name <- paste0(pop.dir, "/", pop.abbrev, '_f_35_', year, '.tiff')
f_40_name <- paste0(pop.dir, "/", pop.abbrev, '_f_40_', year, '.tiff')
f_45_name <- paste0(pop.dir, "/", pop.abbrev, '_f_45_', year, '.tiff')


pop_f_15 <- raster(f_15_name)
pop_f_20 <- raster(f_20_name)
pop_f_25 <- raster(f_25_name)
pop_f_30 <- raster(f_30_name)
pop_f_35 <- raster(f_35_name)
pop_f_40 <- raster(f_40_name)
pop_f_45 <- raster(f_45_name)

raster <- pop_f_45 + pop_f_40 + pop_f_35 + pop_f_30 + pop_f_25 + pop_f_20 + pop_f_15
agg.pop1 <- aggPopulation(
  tiff = raster,
  SpatialPolygons = ZambiaAdm1,
  varname = c("NAME_1")
)
colnames(agg.pop1)[1] <- "admin1.name"
agg.pop2 <- aggPopulation(
  tiff = raster,
  SpatialPolygons = ZambiaAdm2,
  varname = c("NAME_2")
)
```


The computed population estimates in this example is built into the package and available in the `ZambiaPopWomen` dataset.

```{r}
data(ZambiaPopWomen)
head(ZambiaPopWomen$admin1_pop)
head(ZambiaPopWomen$admin2_pop)
```


## Estimating population size by survey weight {#sec:survey-weight-fraction}

An alternative approach to obtain population fractions is to simply use survey weights to estimate the population size within each area. This approach, however, can lead to noisy estimates at fine spatial resolutions. Nevertheless, similar to `aggPopulation()`, the `aggSurveyWeight()` function produces the estimated population size at the specified admin level. The output can be used as weights for aggregation model results to higher admin levels. 


```{r, tidy = TRUE}
agg.survey1<-aggSurveyWeight(data=data,cluster.info=cluster.info,admin=1)
agg.survey2<-aggSurveyWeight(data=data,cluster.info=cluster.info,admin=2,poly.adm = poly.adm2)
```


As mentioned in Section \@ref(sec:data), the `adminInfo()` combine information for each administrative area into a single data frame. This includes the name, population, and fractions of the urban population for each area. Population and urban population fractions can be added through the `agg.pop` and `proportion` objects, respectively. Additionally, the survey weight (output of `aggSurveyWeight()`) may serve as an alternative to population data, and users can add it via `agg.pop`.

```{r, tidy = F}
admin.info1 <- adminInfo(poly.adm = poly.adm1, 
                         admin = 1,
                         agg.pop  =ZambiaPopWomen$admin1_pop,
                         proportion = ZambiaPopWomen$admin1_urban )

admin.info2 <- adminInfo(poly.adm = poly.adm2, 
                         admin = 2,
                         agg.pop =ZambiaPopWomen$admin2_pop,
                         proportion = ZambiaPopWomen$admin2_urban)

admin.info1.survey <- adminInfo(poly.adm = poly.adm1, 
                         admin = 1,
                         agg.pop  =agg.survey1,
                         proportion = ZambiaPopWomen$admin1_urban )

admin.info2.survey  <- adminInfo(poly.adm = poly.adm2, 
                         admin = 2,
                         agg.pop =agg.survey2,
                         proportion = ZambiaPopWomen$admin2_urban)

head(admin.info2$data)
```

The following maps display the 15-49 female population and aggregated DHS survey weights ratio within upper admin levels.

```{r,fig.show='hold',fig.dim = c(6, 4), fig.cap="survey weight ratio and population ratio at Admin 1 and Admin 2", out.width = "100%"}
admin.info1$data$r.population=
  admin.info1$data$population/sum(admin.info1$data$population)
admin.info1.survey$data$r.SurveyWeight=
  admin.info1.survey$data$population/sum(admin.info1.survey$data$population)
admin.info2$data$r.population=
  admin.info2$data$population/admin.info2$data$population.admin1
admin.info2.survey$data$r.SurveyWeight=
  admin.info2.survey$data$population/admin.info2.survey$data$population.admin1
min= min(admin.info1.survey$darta$r.SurveyWeight, admin.info1$data$r.population)
max= max(admin.info1.survey$darta$r.SurveyWeight, admin.info1$data$r.population)
ylim=c(min,max)
g1 <- mapPlot(data = admin.info1.survey$data, geo = poly.adm1, 
              by.data = "admin1.name", by.geo = "NAME_1", 
              variable = "r.SurveyWeight",  legend.label = "rario SurveyWeight",
              removetab = TRUE, ylim = ylim)
g2 <- mapPlot(data= admin.info1$data, geo = poly.adm1, by.data = "admin1.name", 
              by.geo = "NAME_1", variable = "r.population", 
              legend.label = "rario Population", removetab = TRUE, ylim = ylim)
min= min(admin.info2.survey$admin.info$r.SurveyWeight, admin.info2$data$r.population)
max= max(admin.info2.survey$admin.info$r.SurveyWeight, admin.info2$data$r.population)
ylim2=c(min,max)
g3 <- mapPlot(data = admin.info2$data, geo = poly.adm2, 
              by.data = "admin2.name.full", by.geo = "admin2.name.full", 
              variable = "r.population", legend.label = "rario population",
              removetab = TRUE, ylim = ylim2)

g4 <- mapPlot(data = admin.info2.survey$data, geo = poly.adm2, 
              by.data = "admin2.name.full", by.geo = "admin2.name.full", 
              variable = "r.SurveyWeight", legend.label = "rario SurveyWeight", 
              removetab = TRUE, ylim = ylim2)
(g1 + g2) /(g4 + g3)
```


The scatter plots show the comparison of Admin 2 survey weight ratio & 15-49 female population ratio within Admin 1. Noticed that DHS data may have missing Admin 2 areas. For example, Zambia has 112 out of 115 Admin 2 areas for this survey (red points in the scatter plots). Users have to be aware of that this is an incomplete set of weights for aggregation to from Admin 2 to Admin 1. 


```{r, fig.show='hold',fig.dim = c(4, 4),tidy=FALSE, fig.cap="Admin 2 survey weight ratio and 15-49 female population ratio", out.width = "50%", fig.align = 'center'}

df<-left_join(admin.info2$data,admin.info2.survey$data,by="admin2.name.full")
df$pop_r=df$population.x/df$population.admin1.x 
df$survey_weight_r=df$population.y/df$population.admin1.y
missing.admin2=df[!admin.info2$data$admin2.name.full %in%
                    cluster.info$cluster.info$admin2.name.full, ]

ggplot(df, aes(survey_weight_r,pop_r)) +
  geom_point(alpha = 0.5,size =df$population.x/50000)+
   geom_point(data = missing.admin2, aes(survey_weight_r,pop_r), color = "red",
              size=missing.admin2$population.x/50000)+
    geom_abline(slope = 1, intercept = 0, linetype = "dashed")
```


## Aggregated estimates

### Direct estimates {#sec:direct3}

For direct estimates, we caution that we almost always prefer directly computing direct estimates at the desired level, rather than aggregating direct estimates at finer levels. Nevertheless, here we describe how the aggregated direct estimates are computed. 

Let $i$ denote the index for the lower admin level and $k[i]$ be the index for the corresponding upper admin level, then aggregated estimates for the $k$-th upper admin area is 

$$ \hat p^{agg}_{k}=\frac {\sum_{k[i] = k} \hat p^{HT}_{i}E_i}{\sum_{k[i] = k} \text{E}_i},$$
where $E_i=\widehat{\text{pop}_{i}} \times \textbf{1}(\hat p^{HT}_{i} \neq \text{NA})$, i.e., the point estimates are obtained by weighted average of non-missing direct estimates in the area, where the weights are either given by external population information, or estimated by survey weights. The standard error and confidence intervals are computed by simulation using samples from the design-based asymptotic sampling distributions of $\text{logit}(\hat p^{HT}_i)$.
 
The `directEST()` function allows aggregation by survey weight directly by specifying `weight = "survey"`, without going through the steps discussed in Section \@ref(sec:survey-weight-fraction). We compute the direct estimates at admin1 level and aggregate them to national estimates. When using survey weight, the aggregated point estimate at national level is the same as the national level direct estimate, but the uncertainty calculation are different as discussed above. 

```{r, tidy = FALSE}
res_ad1agg <- directEST(data = data,
                   cluster.info = cluster.info,
                   admin = 1, 
                   weight = "population", 
                   admin.info = admin.info1, 
                   aggregation = TRUE)
head(res_ad1agg$res.admin1)
res_ad1agg$agg.natl

```

```{r}
res_ad1agg_bysurvey <- directEST(data = data,
                   cluster.info = cluster.info,
                   admin = 1, 
                   weight = "survey", 
                   admin.info = admin.info1, 
                   aggregation = TRUE)

head(res_ad1agg_bysurvey$agg.natl)
head(res_ad0$res.admin0)
```


Similarly, if we set `admin = 2`, the output includes aggregated results at both the Admin1 and national level  with `aggregation = TRUE`, computed by weighting the Admin 2 level estimates by their population (as specified by `weight = "population"`). 



```{r}
res_ad2agg <- directEST(data = data,
                   cluster.info = cluster.info,
                   admin = 2,
                   admin.info = admin.info2,
                   weight = "population",
                   aggregation = TRUE)
res_ad2agg_bysurvey <- directEST(data = data,
                   cluster.info = cluster.info,
                   admin = 2, 
                   weight = "survey", 
                   admin.info = admin.info2, 
                   aggregation = TRUE)
head(res_ad2agg$res.admin2)
head(res_ad2agg$agg.admin1)
res_ad2agg$agg.natl
```

We can compare these aggregated results at the national level using `intervalPlot()`. 

```{r, tidy = FALSE, fig.cap="Comparing different aggregated direct estimates at national level", fig.dim = c(7, 4), out.width = "100%"}
intervalPlot(admin = 0, group = FALSE, compare = TRUE, 
  model = list(
  "Admin 0 direct estimate" = res_ad0,
  "Admin 2 direct estimate, aggregated by survey" =res_ad2agg_bysurvey,
  "Admin 1 direct estimate, aggregated by survey" =res_ad1agg_bysurvey,
  "Admin 2 direct estimate, aggregated by population" = res_ad2agg,
  "Admin 1 direct estimate, aggregated by population" = res_ad1agg))

```




### Area-level Fay-Herriot estimates {#sec:area-level3}

Aggregation of the Fay-Herriot model can be similarly carried out as model based results. 

```{r}
smth_res_ad1_spatial <- fhModel(data,
                        cluster.info = cluster.info,
                        admin.info = admin.info1,
                        admin = 1,
                        model = "bym2",
                        aggregation = TRUE)


smth_res_ad1_spatial.survey <- fhModel(data,
                        cluster.info = cluster.info,
                        admin.info = admin.info1.survey,
                        admin = 1,
                        model = "bym2",
                        aggregation = TRUE)

```



```{r}
# Run FH model without problematic clusters
smth_res_ad2_agg <- fhModel(subset(data, !cluster %in% bad_clusters),
                    cluster.info = cluster.info,
                    admin.info = admin.info2,
                    admin = 2,
                    model = "bym2",
                    aggregation = TRUE)


smth_res_ad2_agg.survey <- fhModel(subset(data, !cluster %in% bad_clusters),
                    cluster.info = cluster.info,
                    admin.info = admin.info2.survey,
                    admin = 2,
                    model = "bym2",
                    aggregation = TRUE)

```


```{r,fig.cap="Comparing different aggregated Fay-Herriot estimates at national level", fig.dim = c(7, 4), out.width = "100%"}
intervalPlot(admin = 0, group=FALSE, compare=TRUE, model = list(
            "Admin 0 direct estimates" = res_ad0,
            "Admin 2 FH model, aggregated by survey" = smth_res_ad2_agg.survey,
            "Admin 1 FH model, aggregated by survey" = smth_res_ad1_spatial.survey,
            "Admin 2 FH model, aggregated by pop" = smth_res_ad2_agg,
            "Admin 1 FH model, aggregated by pop" = smth_res_ad1_spatial
          ))

```





### Cluster-level model {#sec:cluster-level3}
Here we first fit the unstratified cluster-level model at both Admin 1 and Admin 2, and aggregate to higher levels using both types of weights.

```{r}
cl_res_ad1 <- clusterModel(data=data,
                   cluster.info=cluster.info,
                   admin.info = admin.info1,
                   stratification = FALSE,
                   model = "bym2",
                   admin = 1, 
                   aggregation = TRUE,
                   CI = 0.95)

cl_res_ad1.survey <- clusterModel(data=data,
                   cluster.info=cluster.info,
                   admin.info = admin.info1.survey,
                   stratification = FALSE,
                   model = "bym2",
                   admin = 1, 
                   aggregation = TRUE,
                   CI = 0.95)

cl_res_ad2 <- clusterModel(data=data,
                   cluster.info= cluster.info,
                   admin.info = admin.info2,
                   model = "bym2",
                   stratification = FALSE,
                   admin = 2, 
                   aggregation = TRUE,
                   CI = 0.95)

cl_res_ad2.survey <- clusterModel(data=data,
                   cluster.info= cluster.info,
                   admin.info = admin.info2.survey,
                   model = "bym2",
                   stratification = FALSE,
                   admin = 2, 
                   aggregation = TRUE,
                   CI = 0.95)

```
Similarly we fit the stratified cluster-level model at both Admin 1 and Admin 2, and aggregate to higher levels. Since the urban/rural fractions were computed using population raster, here we use only population weights to aggregate for consistency.


```{r}
cl_res_ad1_T <- clusterModel(data=data,
                   cluster.info=cluster.info,
                   admin.info = admin.info1,
                   model = "bym2",
                   stratification = TRUE,
                   admin = 1, 
                   aggregation = TRUE,
                   CI = 0.95)


cl_res_ad2_T <- clusterModel(data=data,
                   cluster.info = cluster.info,
                   admin.info = admin.info2,
                   model = "bym2",
                   stratification = TRUE,
                   admin = 2, 
                   aggregation = TRUE,
                   CI = 0.95)
```

Finally we compare the six aggregated models with the national direct estimates


```{r,tidy = FALSE, fig.cap="Comparing different aggregated cluster-level estimates at national level", fig.dim = c(7, 4), out.width = "100%"}
intervalPlot(admin = 0, group=FALSE, compare=TRUE, model = list(
            "Admin 0 direct estimates" = res_ad0,
             "Admin 2 unstratified model, aggregated by survey" = cl_res_ad2.survey,
             "Admin 1 unstratified model, aggregated by survey" = cl_res_ad1.survey,
             "Admin 2 unstratified model, aggregated by pop" = cl_res_ad2,
             "Admin 1 unstratified model, aggregated by pop" = cl_res_ad1,
             "Admin 2 stratified model, aggregated by pop" = cl_res_ad2_T,
             "Admin 1 stratified model, aggregated by pop" = cl_res_ad1_T))
```


## Visualizing aggregation results {#sec:vis3}



We can use `SUMMER::mapPlot` to show the model estimates and standard errors.


```{r,fig.show='hold',fig.dim = c(6, 4),tidy = FALSE, fig.cap="Comparing aggregated Admin 2 stratified cluster-level estiamtes, aggregated Admin 2 direct estiamtes, aggregated Admin 2 Fay-Herriot, and Admin 1direct estiamtes", out.width = "100%"}
min= min(res_ad2agg$agg.admin1$direct.est,cl_res_ad2_T$agg.admin1$mean,
         res_ad1agg$res.admin1$direct.est,smth_res_ad2_agg$agg.admin1$mean)
max= max(res_ad2agg$agg.admin1$direct.est,cl_res_ad2_T$agg.admin1$mean,
         res_ad1agg$res.admin1$direct.est,smth_res_ad2_agg$agg.admin1$mean)
ylim=c(min,max)

g1 <- mapPlot(data = cl_res_ad2_T$agg.admin1, geo = poly.adm1, 
              by.data = "admin1.name", by.geo = "NAME_1", variable = "mean", 
              legend.label = "Pop Aggregated\nAdmin2 stratified", 
              ylim =ylim, removetab = TRUE)

g2 <- mapPlot(data = res_ad2agg$agg.admin1, geo = poly.adm1,
              by.data = "admin1.name", by.geo = "NAME_1",
              variable = "direct.est", 
              legend.label = "Pop Aggregated\nAdmin2 Direct",
              ylim =ylim, removetab = TRUE)

g3 <- mapPlot(data = res_ad1$res.admin1, geo = poly.adm1, 
              by.data = "admin1.name", by.geo = "NAME_1",
              variable = "direct.est", legend.label = "Admin1 Direct", 
              ylim = ylim, removetab = TRUE)

g4 <- mapPlot(data = smth_res_ad2_agg$agg.admin1, geo = poly.adm1, 
              by.data = "admin1.name", by.geo = "NAME_1", variable = "mean", 
              legend.label = "Admin 2 Fay-Herriot", 
              ylim = ylim, removetab = TRUE)

(g3 + g2) / (g1 + g4)
```


`intervalPlot()` can provide interval plots at different admin levels for model comparison with `compare=T`. Input should be a list of model outputs by `surveyPrev` with self defined model name, (e.g.`model=list("name 1"= fit1,"name 2"= fit2)`). Then by setting `admin=0,1`, the returned plot will be at given level. You can also group your model by adding group object in your model results like `fit1$model="group1"` and set `group=T`. See following examples at national level and Admin 1 level.


```{r,fig.show='hold',fig.dim = c(8, 4), tidy = FALSE, fig.cap="Comparing different model estimates at national level", out.width = "100%"}
cl_res_ad2_T$group="cluster"
cl_res_ad2$group="cluster"
cl_res_ad1_T$group="cluster"
cl_res_ad1$group="cluster"
res_ad2agg$group="direct est"
res_ad1agg$group="direct est"
smth_res_ad1_spatial$group="fh"
smth_res_ad2_agg$group="fh"
res_ad0$group="direct est"

intervalPlot(admin = 0, group=TRUE, compare=TRUE, model = list(
            "Admin 0 direct estimate model"=res_ad0,
      "Aggregated Admin 2 cluster-level model, stratified"=cl_res_ad2_T,
      "Aggregated Admin 2 cluster-level model, not stratified"=cl_res_ad2,
      "Aggregated Admin 1 cluster-level model, stratified"=cl_res_ad1_T,
      "Aggregated Admin 1 cluster-level model, not stratified"=cl_res_ad1,
      "Aggregated Admin 2 direct estimate model"=res_ad2agg,
      "Aggregated Admin 1 direct estimate model"=res_ad1agg,
      "Aggregated Admin 1 Fay-Herriot model"=smth_res_ad1_spatial,
      "Aggregated Admin 2 Fay-Herriot model"=smth_res_ad2_agg
) )



```

```{r,fig.show='hold',fig.dim = c(12, 5),tidy = FALSE, fig.cap="Comparing different model estimates at Admin 1 level"}

intervalPlot(admin = 1, group=TRUE, compare=TRUE, model = list(
                  "Ad2 cls strat bym2"=cl_res_ad2_T,
                  "Ad2 cls not strat bym2"=cl_res_ad2,
                  "Ad1 cls strat bym2"=cl_res_ad1_T,
                  "Ad1 cls, not strat bym2 "=cl_res_ad1,
                  "Ad2 dir.est  "=res_ad2agg,
                  "Ad1 dir.est  "=res_ad1agg,
                  "Ad1 fh bym2"=smth_res_ad1_spatial,
                  "Ad2 fh bym2"=smth_res_ad2_agg))

```


```{r,fig.show='hold', fig.height = 15, fig.width = 10, fig.cap="Comparing Admin 2 estimates with credible intervals within an Admin 1 region with aggregated results"}
plots<-intervalPlot(compare = FALSE,model = list("model"=cl_res_ad2_T))
patchwork::wrap_plots(plots, ncol = 2)
```





\newpage
# References



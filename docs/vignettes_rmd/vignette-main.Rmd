---
title: "Prevalence mapping for DHS indicators using the **surveyPrev** package"
author: "Qianyu Dong, Zehang Richard Li, Andrea Boskovic, Jon Wakefield"
date: "`r Sys.Date()`"
bibliography: main.bib
output: 
  bookdown::html_document2:
    base_format: rmarkdown::html_vignette
    toc: true
  bookdown::pdf_book:
    number_sections: true
    toc: true
vignette: >
  \VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Prevalence mapping using DHS data}
  %\usepackage[utf8]{inputenc}
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, tidy = FALSE, eval=TRUE, cache = TRUE, out.width = "100%")
```

\clearpage
# Overview

In this vignette, we describe how prevalence mapping using DHS data can be carried out. Prevalence mapping is Small Area Estimation (SAE) for proportions of some indicator of interest. The vignette is organized as follows. In Section \@ref(sec:data) we first describe the data preparation steps to obtain and process the relevant DHS survey data in R. We then describe three classes of models

1. Direct estimates in Section \@ref(sec:direct).
2. Area-level Fay-Herriot model in Section \@ref(sec:area-level).
3. Cluster-level model in Section \@ref(sec:cluster-level).

Then in Section \@ref(sec:aggregation) we discuss how to aggregate the result for a given model to produce estimates at higher admin levels.




# Data Preparation {#sec:data}
  
## Prerequisites

The following pieces of data are needed to produce SAE for DHS surveys:


+ **DHS survey data**: Depending on the indicator, different types of DHS files are used as input. This can be done within R, so there is no need to download files locally from the DHS website. See \@ref(sec:DHS) on downloading DHS data for details.
+ **Spatial polygon files** for the desired admin level: These can be downloaded from GADM site^[[https://gadm.org/download_country.html](https://gadm.org/download_country.html)]. 
+ **Population map** (Optional): These can be downloaded from WorldPop site^[[https://hub.worldpop.org/project/categories?id=8](https://hub.worldpop.org/project/categories?id=8)].These data are only required for the stratified cluster-level model described in Section \@ref(sec:cluster-level-stratified) and for result aggregation described in Section \@ref(sec:aggregation).


## Install _**surveyPrev**_  

The latest **surveyPrev** package can be installed from CRAN with

```{r, eval = FALSE}
install.packages(surveyPrev)
```

The development version of the **surveyPrev** package can be installed from GitHub with

```{r, message=FALSE,warning=FALSE, eval=FALSE}
library(devtools)
install_github("richardli/surveyPrev")
```

After installation, the package can be loaded with 

```{r, message=FALSE,warning=FALSE, eval = TRUE}
library(surveyPrev)
```


One of the key required packages, `INLA` is not available on CRAN or GitHub, and needs to be installed with the following code [@rue2009inla]. 

```{r pkg, eval = FALSE, tidy = FALSE}
install.packages("INLA", repos=c(getOption("repos"), 
                  INLA="https://inla.r-inla-download.org/R/stable"), dep=TRUE)
library(INLA)
```

The following packages are needed to run the example analysis described in this vignette.

```{r, message=FALSE,warning=FALSE, eval = TRUE}
library(geodata)
library(sf)
library(SUMMER)
library(rdhs)
library(ggplot2)
library(patchwork)
library(dplyr)
library(tidyr)
library(kableExtra)
```




## Built-in indicators

```{r, echo = FALSE, eval = TRUE}
data(surveyPrevIndicators)
num=dim((surveyPrevIndicators))[1]
```

Currently, the `surveyPrev` package supports `r num` indicators. The list of indicators and their IDs can be found in the `surveyPrevIndicators` dataset. The ID column correspond to the indicator IDs in the DHS API and are more standardized. The alternative ID column provides convenient and more readable indicator names for only a subset of indicators. Both can be used to retrieve the indicator in the functions described later. The full list of indicators and their IDs are summarized in the Table below.

```{r, eval = FALSE}
data(surveyPrevIndicators)
head(surveyPrevIndicators)
```

```{r indic, eval = TRUE, table.width = "100%", echo = FALSE}
data(surveyPrevIndicators)
is_html_output = function() {
  knitr::opts_knit$get("rmarkdown.pandoc.to") == "html"
}
if(is_html_output()){
  kbl(surveyPrevIndicators[, c("ID", "alternative.ID", "Description", "Topic")], align = 'llll', 
    caption = "List of built-in indicators in the surveyPrev package.") %>%
  kable_styling()
}else{
  kbl(surveyPrevIndicators[, c("ID", "alternative.ID", "Description", "Topic")], align = 'llll', 
    caption = "List of built-in indicators in the surveyPrev package.") %>%
  column_spec(3, width = "20em") %>%
  column_spec(4, width = "8em")
}
```



In this vignette, we consider estimating the percentage of women who had a live birth in the five years before the survey who had four or more antenatal care visits. This indicator can be extracted with `indicator = "ancvisit4+"` or `indicator = "RH_ANCN_W_N4P"`. 


## Customized indicators
Details on more common DHS indicators can be found in the Guide to DHS Statistics^[https://dhsprogram.com/data/Guide-to-DHS-Statistics/](https://dhsprogram.com/data/Guide-to-DHS-Statistics/) by searching for an indicator. User-specified function can also be used to process raw DHS data into new indicators. Please refer to the vignette on _Creating Customized Indicators for **surveyPrev**_ for more details.


## DHS survey data {#sec:DHS} 

Processing the binary indicator from the raw DHS data consist of two steps: 
1. download the relevant DHS data recode using `getDHSdata()`, or manually from the DHS website,
2. create a data frame with the binary indicator and relevant information using `getDHSindicator()`. 

The `getDHSdata()` function downloads the relevant DHS data directly from the DHS website using the **rdhs** package. This step requires users to

1. register with DHS to gain data access, 
2. set up the DHS account login details in R with `rdhs::set_rdhs_config()`.

```{r,eval=FALSE}
rdhs::set_rdhs_config(email = "your_email",
                project = "your_registered_DHS_project_title")
```

After setting up the DHS account information, `getDHSdata()` can be used to download the relevant survey files directly into R. If data download using the API fails, or if it is preferred to work with downloaded data files offline, you may also manually download the file from the DHS website and read into R. The `getDHSdata()` function returns a message specifying which file is used (e.g., Individual Record file for the ANC visit example). 

```{r,message=FALSE,warning=FALSE}
indicator <- "ancvisit4+"
year <- 2018
country <- "Zambia"
dhsData <- getDHSdata(country = country, indicator = indicator, year = year)
```

We then use `getDHSindicator()` to process the raw survey data into a data frame, where the column `value` is the indicator of interest. The data frame also contains information specifying survey designs in the **survey** package, including cluster ID, household ID, survey weight and strata information. 

```{r}
data <- getDHSindicator(dhsData, indicator = indicator)
head(data)
```

## Spatial information

The `getDHSgeo()`function downloads the GPS data for cluster locations, also through the **rdhs** package. This step loads in the GPS location as a `SpatialPointsDataFrame`, but it can also be performed manually by downloading the GPS file from the DHS website. The GPS location of the clusters are used to match clusters to regions at different admin levels. 

```{r}
geo <- getDHSgeo(country = country, year = year)
```

In the case of Zambia, the maps are already included in the package as example datasets (`data(ZambiaAdm1)` and `data(ZambiaAdm2)`) so we load them directly within R. For other countries, the Admin 1 and Admin 2 boundary shapefiles can be downloaded from the GADM site^[[https://gadm.org/download_country.html](https://gadm.org/download_country.html)] and read into R manually. Another alternative is to use the **geodata** and **sf** package to download the maps from the GADM site and load them in R directly, in the following steps:

```{r}
poly.adm1 <- geodata::gadm(country="ZMB", level=1, path=tempdir())
poly.adm1 <- sf::st_as_sf(poly.adm1)
poly.adm2 <- geodata::gadm(country="ZMB", level=2, path=tempdir())
poly.adm2 <- sf::st_as_sf(poly.adm2)
```



The `clusterInfo()` function extracts Admin 1 and Admin 2 area information for each cluster. To avoid confusion in countries that have duplicated region names, we create new labels for Admin 2 regions using the variable `admin2.name.full`.  The clusters with invalid GPS locations are saved in the `wrong.points` object and not used in any models. 

```{r}
cluster.info <- clusterInfo(geo=geo, poly.adm1=poly.adm1, poly.adm2=poly.adm2)
head(cluster.info$data)
cluster.info$wrong.points
```


The `adminInfo()` function computes the spatial the adjacency matrix, and if supplied with additional information on population, combines needed information for each administrative area, including the name, population, and urban population fractions of each administrative area. The `admin.mat` object stores the adjacency matrix for spatial models. We will ignore the population information for now and focus on only information from the DHS data, and will return to the population information in Section \@ref(sec:aggregation). 

```{r}
admin.info1 <- adminInfo(poly.adm = poly.adm1, admin = 1)
admin.info2 <- adminInfo(poly.adm = poly.adm2, admin = 2)
head(admin.info2$data)
```



# Direct estimates {#sec:direct}

## National and Admin 1 direct estimates
For $y_j$ be the binary outcome of interest for the $j^{\text{th}}$ individual in the survey and $w_j$ be the design weight associated with this individual.  For a given area denoted as $i$, we have the weighted estimator:

$$ \hat p^{W}_{i}=\frac {\sum_{j \in S_i} y_j w_j}{\sum_{j \in S_i} w_j}$$

where $S_i$ is the set of individual index within the $i$-th region. The `directEST()` function calculates direct estimates at different Admin levels using the `SUMMER::smoothSurvey()` function in the **SUMMER** package internally [@li2020summer].  The output of the function includes the direct estimates and their variance, standard error, and confidence intervals based on the specified confidence level. The confidence intervals are computed on the logit scale, i.e., if we use $D_i$ to denote the design-based variance of $\hat p^{W}_i$, then the asymptotic design-based variance of $\text{logit}(\hat p^{W}_i)$ is
\[
V_i  = \frac{D_i}{(\hat p^{W}_i)^2(1-\hat p^{W}_i)^2}
\]
and we compute the confidence interval on the probability scale to be 
\[(\quad \text{expit}[\text{logit}(\hat p^{W}_i) - z_{\alpha/2}V_i^{1/2}], \;\;
\text{expit}[\text{logit}(\hat p^{W}_i) + z_{\alpha/2}V_i^{1/2}]\quad).
\]

Currently the package defaults to a two-stage stratified cluster sampling design, with the sampling clusters (enumeration areas) being stratified by Admin 1 areas and urban/rural strata, which is the most common sampling design in the DHS. 


```{r}
res_ad1 <- directEST(data = data,
                   cluster.info = cluster.info,
                   admin = 1)
head(res_ad1$res.admin1)
```


For national level (`admin = 0`), the function can additionally produce urban- and rural-specific direct estimates by specifying argument `strata`. 

```{r}
res_ad0 <- directEST(data=data,
                   cluster.info= cluster.info,
                   admin=0,
                   strata="all")
res_ad0_urban <- directEST(data=data,
                   cluster.info= cluster.info,
                   admin=0,
                   strata="urban")
res_ad0_rural <- directEST(data=data,
                   cluster.info= cluster.info,
                   admin=0,
                   strata="rural")
list(all = res_ad0$res.admin0, 
      urban = res_ad0_urban$res.admin0, 
      rural = res_ad0_rural$res.admin0)
```

## Admin 2 direct estimates {#sec:direct2} 

In general, direct estimates at Admin 2 are unstable. For countries with a large number of Admin 2 areas, some of the direct estimates can be undefined if there is no cluster in the area.

```{r}
res_ad2 <- directEST(data = data,
                     cluster.info = cluster.info,
                     admin = 2,
                     aggregation = FALSE)
```


# Area-level Fay-Herriot model {#sec:area-level}

## Admin 1 Fay-Herriot estimates

Fay-Herriot models provides smoothed estimates at the areal level using direct estimate $\hat p^{W}_{i}$ as input. The direct estimates are modeled as a noisy observation of the true prevalence, with the variance of noise determined by the design-based variance. We consider the spatial Fay-Herriot model for the logit transformed direct estimates, which is defined as follows:

$$\text{logit}(\hat p^{W}_{i})|\lambda_{i} \sim\textrm{Normal}(\lambda_{i}, V_{i}^{HT}),$$
$$\lambda_{i}= \alpha + e_i+S_i.$$
Here $\text{expit}(\lambda_{i})$ is the latent true prevalence, and $e_i$ and $S_i$ are unstructured and structured spatial random effects. Inference is carried out using Bayesian methods and so the model specific is completed by priors on $\alpha$, $e$ and $S$, and their hyperpriors. More details of the Bayesian model setup can be found in @wakefield2020small. Area level Fay-Herriot model are viewed as the most reliable model choice, since they acknowledge the design through the sue of a weighted estimate and its associated variance. See chapters 4 to 6 of @rao2015sae. 



As of now the package allows only an overall intercept $\alpha$, but future versions of the package will allow area level covariates to be included. The default prior for the intercept is $N(0, 1000)$. The structured and non-structured random effects are implemented used Besag-York-Mollié (BYM) via BYM2 parameterization, with default PC priors such that the marginal standard deviation has a prior such that $Prob(\sigma > 1) = 0.01$ and the proportion of variation explained by the spatial effect, $\phi$ has a prior such that $Prob(\phi > 0.5) = 2/3$ [@riebler2016bym2; @simpson2017pc]. 


The `fhModel()` calculates spatial Fay-Herriot estimates at different administrative levels using `SUMMER::smoothSurvey()`. Users can specify either only i.i.d. random effects (i.e., no $S_i$ term) or the BYM2 model by setting `model = "iid"` or `model = "bym2"`. The function returns model results at the specified admin level with `aggregation = FALSE`. Aggregated to higher admin levels is possible with `aggregation = TRUE` when additional population information is provided. The aggregation steps are described in more details in Section \@ref(sec:aggregation). 


```{r}
smth_res_ad1_bym2 <- fhModel(data,
                        cluster.info = cluster.info,
                        admin.info = admin.info1,
                        admin = 1,
                        model = "bym2",
                        aggregation =FALSE)

smth_res_ad1_iid <- fhModel(data, 
                        cluster.info = cluster.info, 
                        admin.info = admin.info1,
                        admin = 1, 
                        model = "iid",
                        aggregation =FALSE)
head(smth_res_ad1_bym2$res.admin1) 
```

Columns 2-6 represent the posterior mean, posterior variance, posterior median and 2.5\%, and 97.5\% posterior quantiles, respectively. The posterior variance can be viewed as an analogue of the mean squared error (MSE) summary.



## Admin 2 Fay-Herriot estimates {#sec:area-level2}

A Fay-Herriot model at Admin 2 level can be fitted by treating areas without direct estimates as missing data, though it is usually not recommended due to data sparsity. In addition, numerical issue arise when design-based variance of direct estimate is close to zero and logit precision become too large. A potential fix for this issue is to identify regions with too small design variance(< 1e-30), and delete the clusters in these regions, before fitting the model. However, this step creates additional bias in the results if the number of clusters deleted is large.


```{r}
bad_admin2 <- subset(res_ad2$res.admin2, direct.var < 1e-30)$admin2.name.full
# identify clusters in these regions
bad_clusters <- subset(cluster.info$data, admin2.name.full %in% bad_admin2)$cluster
# Run FH model without these clusters
smth_res_ad2 <- fhModel(subset(data, !cluster %in% bad_clusters),
                    cluster.info = cluster.info,
                    admin.info = admin.info2,
                    admin = 2,
                    model = "bym2",
                    aggregation = FALSE)
head(smth_res_ad2$res.admin2)
```

# Cluster-level model {#sec:cluster-level}

## Unstratified model

Cluster-level models assume smoothing models for counts of events in each cluster [@wakefield2020small; @li2020summer]. In terms of traditional SAE literature, cluster-level models are a type of unit-level model. We start with describing an unstratified model without taking into account the urban/rural stratification in the sampling design.

Let $Y_c$ be the number of events in cluster $c$, and $n_c$ be the number of individuals at risk, where $c= 1,\dots,C$. The unstratified model assumes the hierarchical structure:

$$Y_c \mid p_c,d\sim \textrm{BetaBinomial}(n_c,p_c,d),$$
$$p_c=\textrm{expit}(\alpha+e_{i[s_c]}+S_{i[s_c]}),$$

where $\alpha$ is the intercept, and $i[s_c]$ indexes the area within which the cluster $s_c$ resides. Similar to the area-level model, $e_i$ and $S_i$ are unstructured and structured spatial random effects with the same prior as before. The Beta-binomial distribution arise from a hierarchical model where the probability follows a $\text{Beta}(a, b)$ prior. The overdispersion parameter, $d=\frac{1}{\alpha+\beta+1}$, is between 0 and 1 and represent the the intracluster correlation between Bernoulli draws within cluster.
<!-- , corr($z_k,z_{k'}$), where $z_k$ is the binary response in $y_c$, $y_c=\sum_{k=1}^{n_c}z_k$). -->
The default prior for $d$ is $\text{logit}(d) \sim \text{Normal}(0,0.4)$.  

The `clusterModel()` function fits the cluster-level model above. Unstratified model can be specified by setting `stratification = FALSE`, and either i.i.d. or the BYM2 model by setting `model = "bym2"` or `model = "iid"`. For the the overdispersion parameter $d$, users can change the prior mean and precision through `overdisp.mean` and `overdisp.prec`. 

We fit the unstratified model in both Admin 1 and Admin 2 below. These models differ only in the admin level at which the spatial random effects enter, with the cluster-level model being the same in each case.


```{r}
cl_res_ad1 <- clusterModel(data=data,
                   cluster.info=cluster.info,
                   admin.info  = admin.info1,
                   stratification = TRUE,
                   model = "bym2",
                   admin = 1,
                   aggregation =FALSE,
                   CI = 0.95)

cl_res_ad2 <- clusterModel(data=data,
                   cluster.info= cluster.info,
                   admin.info = admin.info2,
                   model = "bym2",
                   stratification =FALSE,
                   admin = 2,
                   aggregation =FALSE,
                   CI = 0.95)
head(cl_res_ad2$res.admin2)
```


## Stratified model

Cluster-level models will produce biased estimates if the specified model does not hold for all units in the population. In the DHS, urban clusters are often oversampled. If such oversampling occurs and the outcome associated with urban/rural, then bias will result when the model does not allow for differences between urban/rural. To emphasize, bias will only arise when oversampling of urban (or rural) areas occurs, and the indicator has an association with urban/rural. One may check whether one needs to include urban/rural terms in the model, and then aggregate by urban/rural. 

A fully adjusted model would include interaction terms representing the crossing of Admin 1 areas and urban/rural status. However, for reasons of parsimony we include area-level random effects and a single urban/rural fixed effect. The sampling model becomes

$$Y_c|p_c,d\sim \textrm{BetaBinomial}(n_c,p_c,d),$$
$$p_c=\textrm{expit}(\alpha+\gamma\times I(s_c \in \textrm{urban})+x_c\beta+e_{i[s_c]}+S_{i[s_c]}).$$


The area-level risk is defined as $$p_i=q_i\times \text{expit}(\alpha+\gamma+e_{i[s_c]}+S_{i[s_c]})+(1-q_i)\times \text{expit}(\alpha+e_{i[s_c]}+S_{i[s_c]}),$$ where $q_i$ is the proportion of urban population in area $i$ where "urban" is defined by the survey design sampling frame. 


Stratified cluster-level model can be fit by setting `stratification = TRUE`. The returned results then consist of urban-specific, rural-specific, and the overall area-level prevalences. In order to facilitate aggregation for cluster-level model with urban/rural effects, we need to know the fraction of urban population by each administrative region. This computation can be non-trivial and requires external information (i.e., the urban/rural definition by census), so we omit this step from this document for now and assume such information is already obtained from a difference source. he urban proportions for women of age 15 to 49 in Zambia in 2018 has been pre-computed and saved in `ZambiaPopWomen$admin1_urban` and `ZambiaPopWomen$admin2_urban`.

```{r}
head(ZambiaPopWomen$admin2_urban)
```

Given the urban/rural proportions, we first add the information into `admin.info2` using `adminInfo()`.T


```{r, tidy = F}
admin.info2 <- adminInfo(poly.adm = poly.adm2, 
                         admin = 2,
                         proportion = ZambiaPopWomen$admin2_urban)
head(admin.info2$data)
```

We can then fit the stratified cluster-level model by specifying `stratification = TRUE`. 

```{r}
cl_res_ad2_T <- clusterModel(data=data,
                   cluster.info=cluster.info,
                   admin.info = admin.info2,
                   model = "bym2",
                   stratification = TRUE,
                   admin = 2, 
                   CI = 0.95)
```


# Visualizing prevalence estimates {#sec:vis}

We can use `mapPlot()` function from the **SUMMER** package to visualize estimates and standard errors. 

```{r ,fig.dim = c(9, 5),fig.cap="Comparing Admin 1 direct estimates, Fay–Herriot model, and unstratified cluster-level posterior mean estimates", out.width = "100%"}
# Arrange all estimates into a long-format data frame
out1 <- res_ad1$res.admin1[, c("admin1.name", "direct.est", "cv")]
colnames(out1)[2] <- "mean"
out1$model <- "Direct Estimates"
out2 <- smth_res_ad1_bym2$res.admin1[, c("admin1.name", "mean", "cv")]
out2$model <- "Fay-Herriot Model"
out3 <- cl_res_ad1$res.admin1[, c("admin1.name", "mean", "cv")]
out3$model <- "Unstratified Cluster-level Model"

g1 <- mapPlot(data = rbind(out1, out2, out3), geo = poly.adm1,
              by.data = "admin1.name",  by.geo = "NAME_1", is.long = TRUE, 
              variable = "model", value = "mean", legend.label = "Mean")

g2 <- mapPlot(data = rbind(out1, out2, out3), geo = poly.adm1,
              by.data = "admin1.name",  by.geo = "NAME_1", is.long = TRUE, 
              variable = "model", value = "cv", legend.label = "CV")
g1 / g2 
```

We note that for Admin 2 estimates, **surveyPrev** uses a recreated region name in the form of [admin1_name]\_[admin2_name] to avoid duplicated Admin 2 names. This new region identifier is assigned a column name of `admin2.name.full` in the output. Thus when plotting, we need to manually create the `admin2.name.full` in the spatial polygon object.

```{r ,fig.dim = c(10, 5),fig.cap="Comparing Admin 2 direct estimates, Fay–Herriot model, unstratified and stratified cluster-level posterior mean estimates", out.width = "100%"}
poly.adm2$admin2.name.full=paste0(poly.adm2$NAME_1,"_",poly.adm2$NAME_2)

# Arrange all estimates into a long-format data frame
out1 <- res_ad2$res.admin2[, c("admin2.name.full", "direct.est", "cv")]
colnames(out1)[2] <- "mean"
out1$model <- "Direct Estimates"
out2 <- smth_res_ad2$res.admin2[, c("admin2.name.full", "mean", "cv")]
out2$model <- "Fay-Herriot Model"
out3 <- cl_res_ad2$res.admin2[, c("admin2.name.full", "mean", "cv")]
out3$model <- "Unstratified Cluster-level Model"
out4 <- cl_res_ad2_T$res.admin2[, c("admin2.name.full", "mean", "cv")]
out4$model <- "Stratified Cluster-level Model"

g1 <- mapPlot(data = rbind(out1, out2, out3, out4), geo = poly.adm2,
              by.data = "admin2.name.full",  by.geo = "admin2.name.full", 
              is.long = TRUE, variable = "model", value = "mean", 
              legend.label = "Mean", ncol = 4)

g2 <- mapPlot(data = rbind(out1, out2, out3, out4), geo = poly.adm2,
              by.data = "admin2.name.full",  by.geo = "admin2.name.full", 
              is.long = TRUE, variable = "model", value = "cv", 
              legend.label = "CV", ncol = 4)
g1 / g2 
```


The `scatterPlot()` function takes results from two model outputs, and produce a scatter plot of the selected variable. For example, we can compare the direct estimates with the Fay-Herriot model (top row) and Cluster-level model (bottom row) in terms of their point estimates and standard deviations. In the two plots on the left, we see the expected shrinkage (attenuation) of the spatial Fay–Herriot posterior mean estimates as compared to the direct estimates. In the plots on the right we see the reduction in uncertainty which arises from using all of the data in a single Model.


```{r, warning=FALSE,echo=TRUE,fig.show="hold", fig.height = 8, fig.width = 8, out.width = "100%", fig.cap="Comparing  direct estimates with Fay-Herriot model (top row) and Unstratified cluster-level model (bottom row)."}
s1 <- scatterPlot(
          res1=res_ad1$res.admin1,
          res2=smth_res_ad1_bym2$res.admin1,
          value1="direct.est",
          value2="mean",
          by.res1="admin1.name",
          by.res2="admin1.name",
          title="Fay-Herriot vs Direct estimate",
          label1="Direct Est",
          label2="Spatial Fay-Herriot")
s2 <- scatterPlot(
          res1=res_ad1$res.admin1,
          res2=smth_res_ad1_bym2$res.admin1,
          value1="direct.se",
          value2="sd",
          by.res1="admin1.name",
          by.res2="admin1.name",
          title="Fay–Herriot vs Direct SE",
          label1="Direct Est",
          label2="Spatial Fay–Herriot")
s3 <- scatterPlot(
          res1=res_ad1$res.admin1,
          res2=cl_res_ad1$res.admin1,
          value1="direct.est",
          value2="mean",
          by.res1="admin1.name",
          by.res2="admin1.name",
          title="Cluster-level model vs Direct estimate",
          label1="Direct Est",
          label2="Cluster-level model")
s4 <- scatterPlot(
          res1=res_ad1$res.admin1,
          res2=cl_res_ad1$res.admin1,
          value1="direct.se",
          value2="sd",
          by.res1="admin1.name",
          by.res2="admin1.name",
          title="Cluster-level model vs Direct SE",
          label1="Direct Est",
          label2="Cluster-level model")
(s1 + s2 ) / (s3 + s4)
```
 

Similar smoothing patterns can be observed when comparing estimates at Admin 2 level.


```{r, warning=FALSE,echo=TRUE,fig.show="hold", fig.height = 8, fig.width = 8, out.width = "100%", fig.cap="Comparing  direct estimates with Fay-Herriot model (top row) and Unstratified cluster-level model (bottom row). Red triangles corresponding to areas where direct estimates are not available."}
s1 <- scatterPlot(
          res1=res_ad2$res.admin2,
          res2=smth_res_ad2$res.admin2,
          value1="direct.est",
          value2="mean",
          by.res1="admin2.name.full",
          by.res2="admin2.name.full",
          title="Fay-Herriot vs Direct estimate",
          label1="Direct Est",
          label2="Spatial Fay-Herriot")
s2 <- scatterPlot(
          res1=res_ad2$res.admin2,
          res2=smth_res_ad2$res.admin2,
          value1="direct.se",
          value2="sd",
          by.res1="admin2.name.full",
          by.res2="admin2.name.full",
          title="Fay–Herriot vs Direct SE",
          label1="Direct Est",
          label2="Spatial Fay–Herriot")
s3 <- scatterPlot(
        res1=res_ad2$res.admin2,
        res2=cl_res_ad2_T$res.admin2,
        value1="direct.est",
        value2="mean",
        by.res1="admin2.name.full",
        by.res2="admin2.name.full",
        title="Cluster-level model vs Direct estimate",
        label1="Direct Est",
        label2="Cluster-level model")
s4 <- scatterPlot(
        res1=res_ad2$res.admin2,
        res2=cl_res_ad2_T$res.admin2,
        value1="direct.se",
        value2="sd",
        by.res1="admin2.name.full",
        by.res2="admin2.name.full",
        title="Cluster-level model vs Direct SE",
        label1="Direct Est",
        label2="Cluster-level model")
(s1 + s2 ) / (s3 + s4)
```

Finally, we compare the unstratified and stratified cluster-level model at Admin 2 level. We can observe mild differences but the estimates are mostly similar between the two models.
```{r, warning=FALSE,echo=TRUE,fig.show="hold", fig.height = 4, fig.width = 8, out.width = "100%", fig.cap="Comparing unstratified and stratified cluster-level model at Admin 2 level."}
s1 <- scatterPlot(
          res1=cl_res_ad2$res.admin2,
          res2=cl_res_ad2_T$res.admin2,
          value1="mean",
          value2="mean",
          by.res1="admin2.name.full",
          by.res2="admin2.name.full",
          title="Stratified vs Unstratified model estimate",
          label1="Unstratified model estimates",
          label2="Stratified model estimates")
s2 <- scatterPlot(
          res1=cl_res_ad2$res.admin2,
          res2=cl_res_ad2_T$res.admin2,
          value1="sd",
          value2="sd",
          by.res1="admin2.name.full",
          by.res2="admin2.name.full",
          title="Stratified vs Unstratified model SD",
          label1="Unstratified model estimates",
          label2="Stratified model estimates")
(s1 + s2 )  
```


Another visualization function `intervalPlot()` can provide interval plots at different admin levels for model comparison with `compare=T`. Input should be a list of model outputs by `surveyPrev` with self defined model name, (e.g.`model=list("name 1"= fit1,"name 2"= fit2)`).


```{r,fig.show='hold',fig.dim = c(8, 4), tidy = FALSE, fig.cap="Comparing different Admin 1 estimates.", out.width = "100%"}
intervalPlot(admin = 1, compare = TRUE, model = list(
      "Direct estimate model"= res_ad1,
      "Fay-Herriot model"= smth_res_ad1_bym2,
      "Unstratified Cluster-level model"= cl_res_ad1))
```


For stratified cluster-level models, `intervalPlot()` visualizes the urban, rural, and overall Admin 2 estimates within each Admin 1 region, when setting `compare = FALSE`. 

```{r,fig.show='hold', fig.height = 15, fig.width = 10, fig.cap="Comparing Admin 2 estimates arranged by the corresponding Admin 1 regions.", out.width = "100%"}
plots <- intervalPlot(compare = FALSE, model = list("model"=cl_res_ad2_T))
patchwork::wrap_plots(plots, ncol = 2)
```





# Aggregation to higher admin levels {#sec:aggregation}

## Computing population size from WorldPop raster

Population fractions are necessary to aggregate estimates from finer administrative regions to higher levels. The script below demonstrates the creation of a pixel-level population raster at the 100m by 100m level for women of age 15 to 49 in Zambia in 2018. The corresponding age-sex-specific population estimates can be found at [https://hub.worldpop.org/geodata/summary?id=16429](https://hub.worldpop.org/geodata/summary?id=16429). The path to the downloaded .tiff files are specified in the `pop_dir` object. The `aggPopulation()` aggregates population data from the population raster into admin levels based on the input shapefiles we read in previous step. Here we aggregate pixel-level population for women of age 15 to 49 in Zambia in 2018 into both Admin 1 and Admin 2 levels.

```{r, eval = FALSE}
library(raster)
pop.abbrev <- "ZMB"
year <- 2018
pop.dir <- "../data/Zambia/worldpop"

## first sum up four rasters female  15-49
f_15_name <- paste0(pop.dir, "/", pop.abbrev, '_f_15_', year, '.tiff')
f_20_name <- paste0(pop.dir, "/", pop.abbrev, '_f_20_', year, '.tiff')
f_25_name <- paste0(pop.dir, "/", pop.abbrev, '_f_25_', year, '.tiff')
f_30_name <- paste0(pop.dir, "/", pop.abbrev, '_f_30_', year, '.tiff')
f_35_name <- paste0(pop.dir, "/", pop.abbrev, '_f_35_', year, '.tiff')
f_40_name <- paste0(pop.dir, "/", pop.abbrev, '_f_40_', year, '.tiff')
f_45_name <- paste0(pop.dir, "/", pop.abbrev, '_f_45_', year, '.tiff')


pop_f_15 <- raster(f_15_name)
pop_f_20 <- raster(f_20_name)
pop_f_25 <- raster(f_25_name)
pop_f_30 <- raster(f_30_name)
pop_f_35 <- raster(f_35_name)
pop_f_40 <- raster(f_40_name)
pop_f_45 <- raster(f_45_name)

raster <- pop_f_45 + pop_f_40 + pop_f_35 + pop_f_30 + pop_f_25 + pop_f_20 + pop_f_15
agg.pop1 <- aggPopulation(
  tiff = raster,
  SpatialPolygons = ZambiaAdm1,
  varname = c("NAME_1")
)
colnames(agg.pop1)[1] <- "admin1.name"
agg.pop2 <- aggPopulation(
  tiff = raster,
  SpatialPolygons = ZambiaAdm2,
  varname = c("NAME_2")
)
```


The computed population estimates in this example is built into the package and available in the `ZambiaPopWomen` dataset.

```{r}
data(ZambiaPopWomen)
head(ZambiaPopWomen$admin1_pop)
head(ZambiaPopWomen$admin2_pop)
```


## Estimating population size by survey weight {#sec:survey-weight-fraction}

An alternative approach to obtain population fractions is to simply use survey weights to estimate the population size within each area. This approach, however, can lead to noisy estimates at fine spatial resolutions. Nevertheless, similar to `aggPopulation()`, the `aggSurveyWeight()` function produces the estimated population size at the specified admin level. The output can be used as weights for aggregation model results to higher admin levels. 


```{r, tidy = TRUE}
agg.survey1<-aggSurveyWeight(data=data,cluster.info=cluster.info,admin=1)
agg.survey2<-aggSurveyWeight(data=data,cluster.info=cluster.info,admin=2,poly.adm = poly.adm2)
```


As mentioned in Section \@ref(sec:data), the `adminInfo()` combine information for each administrative area into a single data frame. This includes the name, population, and fractions of the urban population for each area. Population and urban population fractions can be added through the `agg.pop` and `proportion` objects, respectively. Additionally, the survey weight (output of `aggSurveyWeight()`) may serve as an alternative to population data, and users can add it via `agg.pop`.

```{r, tidy = F}
admin.info1 <- adminInfo(poly.adm = poly.adm1, 
                         admin = 1,
                         agg.pop  =ZambiaPopWomen$admin1_pop,
                         proportion = ZambiaPopWomen$admin1_urban )

admin.info2 <- adminInfo(poly.adm = poly.adm2, 
                         admin = 2,
                         agg.pop =ZambiaPopWomen$admin2_pop,
                         proportion = ZambiaPopWomen$admin2_urban)

admin.info1.survey <- adminInfo(poly.adm = poly.adm1, 
                         admin = 1,
                         agg.pop  =agg.survey1,
                         proportion = ZambiaPopWomen$admin1_urban )

admin.info2.survey  <- adminInfo(poly.adm = poly.adm2, 
                         admin = 2,
                         agg.pop =agg.survey2,
                         proportion = ZambiaPopWomen$admin2_urban)

head(admin.info2$data)
```

The following maps display the 15-49 female population and aggregated DHS survey weights ratio within upper admin levels.

```{r,fig.show='hold',fig.dim = c(7.5, 6), fig.cap="survey weight ratio and population ratio at Admin 1 and Admin 2", out.width = "100%"}
out1 <- rbind(cbind(admin.info1$data, type = "WorldPop"), 
             cbind(admin.info1.survey$data, type = "SurveyWeight"))
out1 <- out1 %>% group_by(type) %>% mutate(pop.frac = population / sum(population)) 
g1 <- mapPlot(data = out1, geo = poly.adm1, size = 0.1, 
              by.data = "admin1.name", by.geo = "NAME_1", 
              variable = "type",  value = "pop.frac", is.long = TRUE,
              legend.label = "Population Fraction")

out2 <- rbind(cbind(admin.info2$data, type = "WorldPop"), 
             cbind(admin.info2.survey$data, type = "SurveyWeight"))
out2 <- out2 %>% group_by(type) %>% mutate(pop.frac = population / sum(population)) 
g2 <- mapPlot(data = out2, geo = poly.adm2, size = 0.1, 
              by.data = "admin2.name.full", by.geo = "admin2.name.full", 
              variable = "type",  value = "pop.frac", is.long = TRUE,
              legend.label = "Population Fraction")
g1 / g2
```


The scatter plot below examines the fraction of population residing in each Admin 1 areas, computed by both WorldPop raster and survey weights. Noticed that DHS data may have missing Admin 2 areas. For example, Zambia has 112 out of 115 Admin 2 areas for this survey (red points in the scatter plots). Users have to be aware of that this is an incomplete set of weights for aggregation to from Admin 2 to Admin 1. 


```{r, fig.show='hold',fig.dim = c(6, 4), fig.cap="Comparing two sets of Admin 2 15-49 female population fractions within Admin 1 area.", out.width = "80%", fig.align = 'center'}
out2$pop.frac.within <- out2$population / out2$population.admin1
out3 <- tidyr::spread(out2[, c("admin2.name.full", "pop.frac.within", "type")], 
                      type, pop.frac.within)
out3 <- left_join(out3, admin.info2$data[, c("admin2.name.full", "population")])
ggplot(out3, aes(x = SurveyWeight, y = WorldPop, size = population)) +
    geom_point(alpha = 0.5, color = "red")+
    geom_abline(slope = 1, intercept = 0, linetype = "dashed")
```


## Aggregating Direct estimates {#sec:direct3}

For direct estimates, we caution that we almost always prefer directly computing direct estimates at the desired level, rather than aggregating direct estimates at finer levels. Nevertheless, here we describe how the aggregated direct estimates are computed. 

Let $i$ denote the index for the lower admin level and $k[i]$ be the index for the corresponding upper admin level, then aggregated estimates for the $k$-th upper admin area is 

$$ \hat p^{agg}_{k}=\frac {\sum_{k[i] = k} \hat p^{W}_{i}E_i}{\sum_{k[i] = k} \text{E}_i},$$
where $E_i=\widehat{\text{pop}_{i}} \times \textbf{1}(\hat p^{W}_{i} \neq \text{NA})$, i.e., the point estimates are obtained by weighted average of non-missing direct estimates in the area, where the weights are either given by external population information, or estimated by survey weights. The standard error and confidence intervals are computed by simulation using samples from the design-based asymptotic sampling distributions of $\text{logit}(\hat p^{W}_i)$.
 
The `directEST()` function allows aggregation by survey weight directly by specifying `weight = "survey"`, without going through the steps discussed in Section \@ref(sec:survey-weight-fraction). We compute the direct estimates at admin1 level and aggregate them to national estimates. When using survey weight, the aggregated point estimate at national level is the same as the national level direct estimate, but the uncertainty calculation are different as discussed above. 

```{r, tidy = FALSE}
res_ad1agg <- directEST(data = data,
                   cluster.info = cluster.info,
                   admin = 1, 
                   weight = "population", 
                   admin.info = admin.info1, 
                   aggregation = TRUE)
head(res_ad1agg$res.admin1)
res_ad1agg$agg.natl
```

```{r}
res_ad1agg_bysurvey <- directEST(data = data,
                   cluster.info = cluster.info,
                   admin = 1, 
                   weight = "survey", 
                   admin.info = admin.info1, 
                   aggregation = TRUE)

head(res_ad1agg_bysurvey$agg.natl)
```


Similarly, if we set `admin = 2`, the output includes aggregated results at both the Admin1 and national level  with `aggregation = TRUE`, computed by weighting the Admin 2 level estimates by their population (as specified by `weight = "population"`). 



```{r}
res_ad2agg <- directEST(data = data,
                   cluster.info = cluster.info,
                   admin = 2,
                   admin.info = admin.info2,
                   weight = "population",
                   aggregation = TRUE)
res_ad2agg_bysurvey <- directEST(data = data,
                   cluster.info = cluster.info,
                   admin = 2, 
                   weight = "survey", 
                   admin.info = admin.info2, 
                   aggregation = TRUE)
head(res_ad2agg$res.admin2)
head(res_ad2agg$agg.admin1)
res_ad2agg$agg.natl
```

We can compare these aggregated results at the national level using `intervalPlot()`. 

```{r, tidy = FALSE, fig.cap="Comparing different aggregated direct estimates at national level", fig.dim = c(7, 4), out.width = "100%"}
intervalPlot(admin = 0, group = FALSE, compare = TRUE, 
  model = list(
  "Admin 0 direct estimate" = res_ad0,
  "Admin 2 direct estimate, aggregated by survey" =res_ad2agg_bysurvey,
  "Admin 1 direct estimate, aggregated by survey" =res_ad1agg_bysurvey,
  "Admin 2 direct estimate, aggregated by population" = res_ad2agg,
  "Admin 1 direct estimate, aggregated by population" = res_ad1agg))

```



## Aggregating area-level Fay-Herriot estimates {#sec:area-level3}

Aggregation of the Fay-Herriot model can be similarly carried out as model based results. We first re-fit the Admin 1 model with the two updated `admin.info` objects.

```{r}
smth_res_ad1_spatial <- fhModel(data,
                                cluster.info = cluster.info,
                                admin.info = admin.info1,
                                admin = 1,
                                model = "bym2",
                                aggregation = TRUE)
smth_res_ad1_spatial_survey <- fhModel(data,
                                      cluster.info = cluster.info,
                                      admin.info = admin.info1.survey,
                                      admin = 1,
                                      model = "bym2",
                                      aggregation = TRUE)
```


We also re-fit the Admin 2 model with the two updated `admin.info` objects.
```{r}
# Run FH model without problematic clusters
smth_res_ad2_agg_pop <- fhModel(subset(data, !cluster %in% bad_clusters),
                                cluster.info = cluster.info,
                                admin.info = admin.info2,
                                admin = 2,
                                model = "bym2",
                                aggregation = TRUE)
smth_res_ad2_agg_survey <- fhModel(subset(data, !cluster %in% bad_clusters),
                                  cluster.info = cluster.info,
                                  admin.info = admin.info2.survey,
                                  admin = 2,
                                  model = "bym2",
                                  aggregation = TRUE)
```

And we can compare all four models when aggregating to national level, with the national direct estimate as an additional comparison.
```{r,fig.cap="Comparing different aggregated Fay-Herriot estimates at national level", fig.dim = c(7, 4), out.width = "100%"}
intervalPlot(admin = 0, group = FALSE, compare = TRUE, model = list(
            "Admin 0 direct estimates" = res_ad0,
            "Admin 2 FH model, aggregated by survey" = smth_res_ad2_agg_survey,
            "Admin 1 FH model, aggregated by survey" = smth_res_ad1_spatial_survey,
            "Admin 2 FH model, aggregated by pop" = smth_res_ad2_agg_pop,
            "Admin 1 FH model, aggregated by pop" = smth_res_ad1_spatial))
```

We can also compare all four set of results at the Admin 1 level, with the Admin 1 direct estimate as an additional comparison.
```{r,fig.cap="Comparing different aggregated Fay-Herriot estimates at national level", fig.dim = c(10, 5), out.width = "100%"}
intervalPlot(admin = 1, group = FALSE, compare = TRUE, model = list(
            "Admin 1 direct estimates" = res_ad1,
            "Admin 1 FH model" = smth_res_ad1_spatial_survey,
            "Admin 2 FH model, aggregated by survey" = smth_res_ad2_agg_survey,
            "Admin 2 FH model, aggregated by pop" = smth_res_ad2_agg_pop))
```





## Aggregating cluster-level model {#sec:cluster-level3}
In the same manner, we fit the unstratified and stratified cluster-level model at both Admin 1 and Admin 2 levels. For simplicity of presentation, here we use only the population fractions derived from WorldPop. Results aggregating with survey weights produce very similar results and can be obtained by replacing `admin.info` argument with the corresponding object computed survey weights, i.e., `admin.info1.survey` and `admin.info2.survey`.

```{r}
cl_res_ad1_pop <- clusterModel(data=data,
                               cluster.info=cluster.info,
                               admin.info = admin.info1,
                               stratification = FALSE,
                               model = "bym2",
                               admin = 1, 
                               aggregation = TRUE,
                               CI = 0.95)
cl_res_ad2_pop <- clusterModel(data=data,
                               cluster.info= cluster.info,
                               admin.info = admin.info2,
                               model = "bym2",
                               stratification = FALSE,
                               admin = 2, 
                               aggregation = TRUE,
                               CI = 0.95)
cl_res_ad1_T_pop <- clusterModel(data=data,
                                 cluster.info=cluster.info,
                                 admin.info = admin.info1,
                                 model = "bym2",
                                 stratification = TRUE,
                                 admin = 1, 
                                 aggregation = TRUE,
                                 CI = 0.95)
cl_res_ad2_T_pop <- clusterModel(data=data,
                                 cluster.info = cluster.info,
                                 admin.info = admin.info2,
                                 model = "bym2",
                                 stratification = TRUE,
                                 admin = 2, 
                                 aggregation = TRUE,
                                 CI = 0.95)
```

Finally we compare the different aggregated national estimates with the national direct estimates


```{r,tidy = FALSE, fig.cap="Comparing different aggregated cluster-level estimates at national level", fig.dim = c(7, 4), out.width = "100%"}
intervalPlot(admin = 0, group = FALSE, compare = TRUE, model = list(
            "Admin 0 direct estimates" = res_ad0,
             "Admin 1 unstratified model, aggregated by pop" = cl_res_ad1_pop,
             "Admin 2 unstratified model, aggregated by pop" = cl_res_ad2_pop,
             "Admin 1 stratified model, aggregated by pop" = cl_res_ad1_T_pop,
             "Admin 2 stratified model, aggregated by pop" = cl_res_ad2_T_pop))
```


And we can also compare the different model estimates at the Admin 1 level, together with the Admin 1 direct estimates

```{r,tidy = FALSE, fig.cap="Comparing different cluster-level estimates at Admin 1 level", fig.dim = c(10, 5), out.width = "100%"}
intervalPlot(admin = 1, group = FALSE, compare = TRUE, model = list(
             "Admin 1 direct estimates" = res_ad1,
             "Admin 1 unstratified model" = cl_res_ad1_pop,
             "Admin 2 unstratified model, aggregated by pop" = cl_res_ad2_pop,
             "Admin 1 stratified model" = cl_res_ad1_T_pop,
             "Admin 2 stratified model, aggregated by pop" = cl_res_ad2_T_pop))
```


Finally, we put together all the different Admin 1 level results based on both Fay-Herriot and cluster-level models. When comparing many estimates, it is usually useful to highlight groups of similar models. This can be done by specifying a `group` object in the fitted models, and set `group = TRUE` in `intervalPlot()`.

```{r,fig.show='hold',fig.dim = c(10, 7), tidy = FALSE, fig.cap="Comparing different model estimates at national level", out.width = "100%"}
res_ad1$group <- "Direct Est"
smth_res_ad1_spatial_survey$group <- "Fay-Herriot"
smth_res_ad2_agg_survey$group <- "Fay-Herriot"
smth_res_ad2_agg_pop$group <- "Fay-Herriot"
cl_res_ad1_pop$group <- "Cluster-level"
cl_res_ad2_pop$group <- "Cluster-level"
cl_res_ad1_T_pop$group <- "Cluster-level"
cl_res_ad2_T_pop$group <- "Cluster-level"
intervalPlot(admin = 1, group = TRUE, compare = TRUE, model = list(
                 "Admin 1 direct estimates" = res_ad1,
                 "Admin 1 FH model" = smth_res_ad1_spatial_survey,
                 "Admin 2 FH model, aggregated by survey" = smth_res_ad2_agg_survey,
                 "Admin 2 FH model, aggregated by pop" = smth_res_ad2_agg_pop,
                 "Admin 1 unstratified model" = cl_res_ad1_pop,
                 "Admin 2 unstratified model, aggregated by pop" = cl_res_ad2_pop,
                 "Admin 1 stratified model" = cl_res_ad1_T_pop,
                 "Admin 2 stratified model, aggregated by pop" = cl_res_ad2_T_pop))
```


\clearpage
# Acknowledgement {-}
We thank Ben Mayala and Trevor Croft from the Demographic and Health Surveys (DHS) program for useful discussions in creating this R package.

# References


